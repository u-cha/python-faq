---
title: Вопросы на подумать
description: Вопросы и ответы на сайте-методичке Python FAQ.
---

## У нас 2 объекта data, надо рассчитать сколько полных лет, чисто на python, используя библиотеки?
Для двух дат в Python полные годы обычно считают так: сравнивают разницу по годам и при необходимости вычитают 1, если «день‑месяц» второй даты ещё не достиг «день‑месяц» первой.​

**Вариант на чистом datetime**
```python
from datetime import date

def full_years_between(d1: date, d2: date) -> int:
    if d2 < d1:
        d1, d2 = d2, d1  # чтобы d1 <= d2

    years = d2.year - d1.year
    # если ещё не наступил «день рождения» в году d2, уменьшаем на 1
    if (d2.month, d2.day) < (d1.month, d1.day):
        years -= 1
    return years


a = date(2000, 5, 10)
b = date(2025, 5, 9)
print(full_years_between(a, b))  # 24
```
Здесь используются только стандартные классы date из модуля datetime, без сторонних пакетов.​

**Вариант со сторонней библиотекой**

Если разрешены внешние библиотеки, можно использовать python-dateutil с relativedelta, он сам корректно посчитает разницу в годах:​

```python
from datetime import date
from dateutil.relativedelta import relativedelta

d1 = date(2000, 5, 10)
d2 = date(2025, 5, 9)

delta = relativedelta(d2, d1)
full_years = delta.years  # количество полных лет
print(full_years)  # 24
```
Под «полные годы» в обоих вариантах понимается количество «дней рождения», которые успели пройти между датами.

**Этапы создания объекта**

1. Вызов класса: obj = MyClass(args) — класс выступает как конструктор/фабрика.

2. `__new__(cls, *args)` — создаёт объект в памяти (часто `super().__new__(cls)`), возвращает self.

3. `__init__(self, *args)` — инициализирует `self.attr = value`, выполняется на уже созданном объекте.

```python
class Example:
    def __init__(self, value):
        self.value = value  # Инициализация после создания

obj = Example(42)  # Автоматически: __new__ → __init__
```
**Кто "создатель" на разных уровнях**
* **Разработчик**: вызывает класс напрямую.

* **Интерпретатор**: через __new__ + __init__ (или __call__ для метаклассов).

* **Встроенные типы** (int, list): аналогичный механизм, но с предопределёнными реализациями.

## Как динамически создать класс в runtime?
В Python динамически создавать классы во время выполнения программы (runtime) можно с помощью функции `type()` или метаклассов. Динамическое создание классов — это генерация классов программно, а не их явное определение в исходном коде. 

#### **С помощью функции type()**

Функция `type()` — встроенный метакласс, который позволяет создавать новые классы. 

Синтаксис: `type(name, bases, attributes)`.   
Параметры:   
`name` — имя нового класса.  
`bases` — кортеж базовых классов (классов, которые унаследует новый класс).  
`attributes` — словарь с атрибутами будущего класса (обычно со строками в ключах и вызываемыми типами в значениях).

Пример:
```
MyClass = type('MyClass', (object,), dict()) — создаёт класс с именем MyClass, наследуется от object по умолчанию. 
MyClass = type('MyClass', (), {'x': 42}) — создаёт класс с атрибутом x. 
```
Атрибуты добавляются в класс на стадии инициализации в качестве третьего аргумента — словаря. В словаре можно указать имена атрибутов и значения.
Если нужно, чтобы класс наследовался от другого класса, его передают второму аргументу при определении класса с использованием `type()`.
 
#### **С помощью метаклассов**
Метакласс — специальный класс, который позволяет программно создавать новые классы. Чтобы динамически сгенерировать класс с помощью метакласса, нужно вызвать его с соответствующими аргументами.   
По умолчанию Python использует встроенный метакласс — `type`. Можно создать свой метакласс. Для этого нужно определить новый класс, который наследуется от `type`. В метаклассе можно определить два специальных метода:  
`new()` — вызывается, когда метакласс используется для создания объекта нового класса, отвечает за создание и возврат объекта нового класса.  
`init()` — вызывается после создания объекта нового класса, отвечает за инициализацию атрибутов класса.

Пример:
```
class MyMeta(type): pass — определяет новый метакласс MyMeta, который наследуется от type.
class MyClass(metaclass=MyMeta): pass — создаёт класс, который использует MyMeta в качестве метакласса.
```

## Из-за чего Python "медленный"?
Python медленный по нескольким фундаментальным причинам, связанным с его дизайном и реализацией в CPython.

**Интерпретируемость байт-кода**  
Python не компилируется в машинный код заранее — исходный код преобразуется в промежуточный байт-код (.pyc), который интерпретатор выполняет построчно в runtime через виртуальную машину (PVM).
Каждая инструкция требует lookup'ов в словарях, проверки типов и динамических вызовов, что в 10–100 раз медленнее нативного кода C/C++.

**Динамическая типизация**  
Переменные не имеют фиксированного типа — каждый раз при обращении к объекту Python проверяет тип, ищет методы в `__dict__` или MRO (Method Resolution Order).
Динамические атрибуты (setattr, monkey-patching) и слабая ссылочная семантика добавляют накладные расходы на каждый доступ/вызов.

**Global Interpreter Lock (GIL)**  
В CPython один поток не может выполнять Python-код параллельно с другим из-за GIL — глобальной блокировки, защищающей счётчик ссылок (refcount).
Это убивает CPU-bound многопоточность; для параллелизма нужны multiprocessing или async (но только для I/O).

**Объектоцентричность всего**   
Всё в Python — объект с overhead: даже int занимает ~28 байт вместо 4–8 у C-int, плюс GC-паузы и частые аллокации.  
Списки/словари — хэш-таблицы с высокой константой, а не массивы в памяти.

## Что такое "слабая" ссылка?
"Слабая ссылка" (англ. weak reference) — это специальный тип ссылки на объект в программировании, который не препятствует удалению этого объекта сборщиком мусора.

Обычная (сильная) ссылка "удерживает" объект в памяти: пока на него есть хотя бы одна такая ссылка — он не будет удалён.
А слабая ссылка не удерживает объект. Если все обычные ссылки на объект исчезли, то даже если есть слабые — объект будет удалён из памяти.

Где применяется?
* Кэширование
* Системы наблюдения (observer pattern)
* Деревья с родительскими ссылками (например, DOM)
* Оптимизация памяти в длительных процессах

Модуль weakref — это встроенный модуль Python, который позволяет создавать слабые ссылки (weak references) на объекты.
```
import weakref

class Well:
    def __init__(self, name):
        self.name = name

well = Well("WELL-101")
weak_ref = weakref.ref(well)  # слабая ссылка

print(weak_ref())  # <__main__.Well object> — объект жив

del well          # последняя сильная ссылка удалена
print(weak_ref())  # None — объект уничтожен сборщиком мусора
```
## Что такое потокобезопасность?

Потокобезопасность (thread safety) — это свойство кода, функции или объекта, которое гарантирует корректную работу при одновременном доступе из нескольких потоков.
Другими словами, потокобезопасный код не сломается и не даст неверных результатов, даже если его используют несколько потоков одновременно.
В потокобезопасной программе потоки могут свободно обращаться к одним и тем же структурам данных, ведь механизм синхронизации всегда поддерживает их в согласованном состоянии.

## Как связаны потокобезопасность и состояние гонки и почему это разные понятия?

Понятия потокобезопасности и состояния гонки (race condition) тесно связаны, но они не являются синонимами. Наоборот, это взаимоисключающие состояния: одно описывает желаемую характеристику кода, а другое — ошибку, возникающую при её отсутствии.

**Состояние гонки** — это проблема, которая возникает, когда несколько потоков одновременно читают и/или изменяют общий ресурс (например, переменную), и результат зависит от случайного порядка выполнения.
**Потокобезопасность** — это свойство кода, которое гарантирует отсутствие таких проблем, то есть исключает состояние гонки.

Если в коде возможно состояние гонки — значит, он не является потокобезопасным.
Если код потокобезопасен — состояние гонки в нём невозможно по определению.

## Как обеспечить потокобезопасность и избежать состояния гонки?
В Python обеспечение потокобезопасности и предотвращение состояния гонки (race condition) требует особого внимания, несмотря на наличие GIL (Global Interpreter Lock). GIL защищает интерпретатор Python от одновременного выполнения байт-кода в нескольких потоках, но не гарантирует потокобезопасность на уровне логики программы, особенно при работе с разделяемыми переменными.

Ниже приведены основные способы обеспечения потокобезопасности в Python:

1. **Использование threading.Lock (мьютексов)**
Это самый распространённый способ защиты критических секций.

```python
import threading

counter = 0
lock = threading.Lock()

def increment():
    global counter
    for _ in range(100000):
        with lock:  # или lock.acquire() / lock.release()
            counter += 1

t1 = threading.Thread(target=increment)
t2 = threading.Thread(target=increment)

t1.start()
t2.start()
t1.join()
t2.join()

print(counter)  # Без lock могло бы быть < 200000```
```
Важно: GIL не защищает от race condition при операциях вроде counter += 1, так как это не атомарная операция (читает, изменяет, записывает).

2. **Атомарные операции и встроенные потокобезопасные структуры**  

Некоторые операции и структуры данных в Python частично потокобезопасны благодаря GIL:

* Методы `.append()`, `.pop()` у списков — атомарны.
* Операции присваивания по ключу в `dict` — атомарны.
* Но составные операции (например, `if key in d: d[key] += 1`) — **не атомарны** и требуют блокировки.
⚠️ Не полагайтесь на GIL для потокобезопасности логики!

3. **Использование queue.Queue для обмена данными между потоками**

Модуль queue предоставляет встроенные потокобезопасные очереди:
```python
import queue
import threading

q = queue.Queue()

def producer():
    for i in range(5):
        q.put(i)

def consumer():
    while True:
        item = q.get()
        if item is None:
            break
        print(f"Got {item}")
        q.task_done()

t1 = threading.Thread(target=producer)
t2 = threading.Thread(target=consumer)
t2.daemon = True

t1.start()
t2.start()
q.join()
```
`queue.Queue` использует внутренние блокировки и условные переменные, поэтому безопасен для многопоточного использования.

4. **Использование threading.local() для локальных данных потока**

Если каждый поток должен иметь свои собственные данные:
```
import threading

local_data = threading.local()

def process():
    local_data.value = threading.current_thread().name
    print(local_data.value)

t1 = threading.Thread(target=process)
t2 = threading.Thread(target=process)

t1.start()
t2.start()
```
Это избегает гонок, так как данные не разделяются.

5. **Использование concurrent.futures.ThreadPoolExecutor**

Хотя это не решает гонки напрямую, упрощает управление потоками и позволяет лучше структурировать код, минимизируя разделяемое состояние.

```python
from concurrent.futures import ThreadPoolExecutor

shared_counter = 0
lock = threading.Lock()

def task(n):
    global shared_counter
    for _ in range(n):
        with lock:
            shared_counter += 1

with ThreadPoolExecutor(max_workers=2) as executor:
    executor.map(task, [100000, 100000])

print(shared_counter)
```
6. **Альтернатива: отказ от потоков в пользу процессов (multiprocessing)**

Если задача CPU-bound и не требует частого обмена данными, используйте multiprocessing. У каждого процесса — своё пространство памяти, поэтому состояния гонки невозможны, но обмен данными сложнее.


