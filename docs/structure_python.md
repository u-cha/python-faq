---
title: Устройство Python
description: Вопросы и ответы по устройству Python на сайте-методичке Python FAQ.
---


## Чем отличается модуль от пакета?
Пакет представляет собой коллекцию модулей, а модуль — файл или набор файлов.

Вот так импортируется пакет:

    from package import module

А так — модуль:

    import module

---

## Что происходит при запуске кода в Python?
Python — интерпретируемый язык программирования, поэтому коду не нужна компиляция. Он выполняется на ходу, но используется промежуточная форма, которая называется компиляцией байт-кода.

Вот как это происходит под капотом:
- при первом запуске кода на Python интерпретатор компилирует его в байт-код;
- после этого виртуальная машина Python (PVM) выполняет его;
- байт-код хранится в папке pycache, у таких файлов расширение .pyc;
- периодически Python проверяет, есть ли у файла .py скомпилированный байт-код в формате .pyc. Если его нет или он старше основного файла, то процесс компиляции запускается снова.

Условный процесс компиляции кода на Python осуществляется с помощью интерпретатора. Полученный байт-код выполняется PVM.

---

## Сборщик мусора
В Python автоматическая сборка мусора. Это значит, что разработчику не надо явно следить за выделением и освобождением памяти. Система сама управляет памятью объектов без ссылок.
Сборщик мусора запускается периодически и ищет объекты, на которые больше не ссылается ни одна переменная в коде. Затем эти объекты идентифицируются как мусор и удаляются из памяти. Сборщик мусора работает, отслеживая ссылки на объекты в памяти, используя механизм подсчета ссылок. Каждый раз, когда создается новая ссылка на объект, счетчик ссылок для этого объекта увеличивается. Точно так же, когда ссылка удаляется, счетчик ссылок уменьшается.

Иногда несколько объектов могут ссылаться друг на друга. В этих случаях Python использует функцию обнаружения циклов, которая находит такие объекты и удаляет зацикленные ссылки.

---

## Что такое GIL?
**GIL (Global Interpreter Lock)** - это механизм, который обеспечивает потокобезопасность интерпретатора. Это особенно важно в контексте многопоточности, поскольку GIL ограничивает выполнение кода только одним потоком за раз. Другими словами, в любой момент времени только один поток может выполняться в одном процессе. Это сделано для предотвращения гонок данных и других проблем, связанных с параллельным доступом к общим ресурсам.
В любой момент может выполняться только один поток Python. Глобальная блокировка интерпретатора — GIL — тщательно контролирует выполнение тредов. GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора (и соответствующие вызовы C-расширений работают правильно).
Принцип работы прост: потоки удерживают GIL, пока выполняются. Однако они освобождают его при блокировании для операций ввода-вывода. Каждый раз, когда поток вынужден ждать, другие, готовые к выполнению потоки, используют свой шанс запуститься.
Когда поток начинает работу, он выполняет захват GIL. Спустя какое-то время планировщик процессов решает, что текущий поток поработал достаточно, и передает управление следующему потоку. Поток №2 видит, что GIL захвачен, так что он не продолжает работу, а погружает себя в сон, уступая процессор потоку №1.
Однако, такое поведение GIL может стать причиной проблем с производительностью, особенно на многоядерных системах, где несколько потоков могли бы выполняться параллельно.

Проблемы, связанные с использованием GIL, включают в себя невозможность полностью использовать потенциал многоядерных систем в Python для параллельного выполнения задач CPU-интенсивного характера. Это ограничение особенно заметно при выполнении вычислительно интенсивных задач, где несколько потоков могли бы значительно ускорить обработку данных, но из-за GIL они вынуждены конкурировать за доступ к общим ресурсам. Кроме того, GIL может стать причиной проблем при разработке многопоточных приложений, так как программистам нужно аккуратно управлять доступом к общим ресурсам, чтобы избежать блокировок и гонок данных.

---

## Исключения

Обработка исключений в Python реализуется с помощью конструкции try—except—finally:

    try:
        # Python пробует выполнить эту часть кода
    except:
        # к этому блоку переходит, если не получилось выполнить try
    finally:
        # этот блок выполняется всегда

Ветка else в конструкции _try…except…else_ будет выполнена только в том случае, если исключения не было возбуждено в блоке try. Если в блоке try произошло исключение, то выполнение программы переходит к соответствующему блоку except, и ветка else пропускается. Если блок except не указан, то исключение будет возбуждено дальше, а программа завершится с сообщением об ошибке.

<details>
  <summary>Пример, в котором будет выполнена ветка else</summary>
    try:
       # some code here
    except:
       # code to handle the exception
    else:
       # code to execute if there is no exceptionп

Если в блоке try не возникает исключений, то выполняется код в блоке else.
</details>

---

### Разница между is и ==
`==` проверяет, одинаковые ли значения у перменных (проверка равенства значений)

`is` проверяет, указывают ли переменные на один и тот же объект (проверка идентичности)

    a = [1, 2]
    b = [1, 2]
    
    print(a == b) #True
    print(a is b) #False

---

### Копия и глубокая копия
**Метод copy()** создает поверхностную копию объекта, то есть создает новый объект, который содержит ссылки на те же объекты, что и исходный объект. Если вы измените какой-либо из этих объектов, изменения отразятся и на копии, и на исходном объекте.

**Метод deepcopy()** создает глубокую копию объекта, то есть создает новый объект, который содержит копии всех объектов, на которые ссылаются элементы исходного объекта. Если вы измените какой-либо из этих объектов, изменения не отразятся на копии или на исходном объекте.

    import copy
    
    # создание копии объекта
        new_list = old_list.copy()
    
    # создание глубокой копии объекта
        new_list = copy.deepcopy(old_list)
    где old_list - исходный список, а new_list - его копия.

_Примечание_: для выполнения глубокого копирования объектов, сами объекты также должны поддерживать копирование. Если объекты в ваших данных не поддерживают копирование, deepcopy() вернет исходный объект, а не его копию.
