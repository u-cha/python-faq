---
title: Коллекции
description: Вопросы и ответы по коллекциям Python на сайте-методичке Python FAQ.
---


## Типы данных Python
- Неизменяемые (немутабельные, immutable) типы данных:  числа (int, float), строки (str), булевые (bool), кортежи (tuple) и frozenset. Также -  None, complex, bytes. 
- Изменяемые (мутабельные, muttable) типы данных. К изменяемым относятся списки (list), множества (set) и словари (dict). Также байтовый массив bytearray.
 
Изменяемые типы данных могут быть изменены после их создания, а неизменяемые — нет.

**None** - экземпляр типа объекта NoneType и особая переменная, которая не имеет целевого значения

**bool** - булевы значения (True, False)

**int** -  целые чисел, как положительныхе, так и отрицательные

**float** - числа, которые могут иметь десятичную часть (с плавающей точкой)

**complex** - комплексные числа

**str** - текстовая информация (строка, последовательность символов)

**tuple** - неизменяемые упорядоченные коллекции элементов (кортежи)

**bytes** - байтовые последовательности, которые используются для работы с бинарными файлами

**frozenset** - неизменяемый тип данных, представляющий неупорядоченную коллекцию уникальных элементов

**list** - изменяемые упорядоченные коллекции элементов (списки)

**dict** - ассоциативный массив, пары «ключ-значение», где каждый ключ является уникальным

**set** - неупорядоченная и неиндексированная коллекция уникальных элементов

**bytearray** - массив заданных байтов

---

## Отличие списка от кортежа

Список и кортеж в Python различаются главным образом изменяемостью: список является изменяемым (может быть изменен после создания), тогда как кортеж является неизменяемым (не может быть изменен после создания). Это означает, что элементы списка можно добавлять, удалять или изменять, а элементы кортежа после создания остаются неизменными.

Под список выделяется определенное место в памяти, когда оно заканчивается (после добавления новых элементов) выделяется новое место памяти большего размера, в которое переносится весь список, для кортежа выделяется фиксированное место в памяти и никогда не меняется, так как кортеж неизменяем(поэтому работа с ним быстрее)

---

## Что может быть ключом в словаре?
Словари представляют собой хеш-таблицы. Вместо ключей в словаре, по сути, используется хэши. 
_(Благодаря этому поиск по словарю происходит быстро и эффективно)_

Соответственно, ключом в словаре может быть любой хэшируемый тип данных, а это **все не изменяемые типы данных**

_Кортеж (tuple) не может быть ключом в словаре, в том случае если в нем изменяемые типы данных._

---

## Как dict и set реализованы внутри?
Dict и Set реализованы в виде хэш-таблицы.

**Хэш-таблица** — это структура данных, которая использует хэш-функцию для преобразования ключа в индекс в массиве, где хранятся значения. Затем элемент добавляется в массив по соответствующему индексу.

Сложность получения элемента в Dict и Set в наилучшем случае составляет O(1), поскольку элемент может быть получен просто с помощью хэш-функции в качестве индекса массива. Однако в худшем случае, когда возникают хэш-коллизии, сложность может вырасти до O(n), где n — количество элементов в таблице.
Также стоит заметить, что сложность операций добавления, удаления и поиска элементов в Set и Dict также составляет O(1) в наилучшем случае и O(n) в худшем случае.

---

## Коллизия
**Kоллизия** - случай, когда хеш функция возвращает идентичный хеш для различных объектов.

Способов бороться с хеш-коллизиями концептуально два.

- Метод цепочки

В этом методе каждая ячейка массива — это указатель на связный список пар ключ-значение, соответствующих одному и тому же хеш-значению ключа. Коллизии просто приводят к тому, что появляются цепочки длиной больше одного элемента.

<details>
  <summary>Пример</summary>
  Это как если положить все книги с одинаковым номером на одну полку. Тогда при поиске книги придется найти нужную полку, взять первую книгу и прочитать название. Если не та — проверить следующую, и так далее. В худшем случае все `n` книг попадут на одну полку и сложность получится O(n).
</details>

_Недостатки_: при большом числе коллизий производительность может снижаться до линейного поиска внутри списка.

- Открытая адресация

В этом случае в ячейки помещаются не указатели на списки, а сами пары ключ-значение. Алгоритм такой: вычисляем хеш-функцию, проверяем нужную ячейку. Если искомого элемента нет, то ищем в следующей ячейке. Следующую ячейку выбирают разными методами: это может быть просто фиксированный интервал до следующей ячейки, повторное хеширование вспомогательной хеш-функцией или другие методы.

<details>
  <summary>Пример</summary>
Говоря языком библиотекаря, в этом случае библиотека получается большая, но полупустая. Потому что если полка, на которую вы хотели положить книгу, оказалась занята, вы выбираете другую свободную полку и кладете книгу туда. А потом по такому же алгоритму вычисляете, где находится нужная книга.
</details>

_Недостатки_: открытая адресация может вызвать проблемы с заполнением таблицы, так как более высокая степень заполненности снижает производительность из-за длинных цепочек поиска.

### Наиболее распространённые методы поиска
- Линейное пробирование (Linear Probing): Если ячейка занята, проверяются следующие ячейки последовательно (например, i+1, i+2, i+3, ...), пока не найдётся свободная.
- Квадратичное пробирование (Quadratic Probing): Если ячейка занята, следующая проверяемая ячейка находится по формуле i + 1^2, i + 2^2, i + 3^2, .... Это помогает снизить проблему кластеризации, характерную для линейного пробирования.
- Двойное хеширование (Double Hashing): Если ячейка занята, используется вторая хеш-функция для определения шага поиска свободной ячейки. Например, если первая хеш-функция дала результат h1, а вторая хеш-функция даёт h2, ячейки проверяются по формуле i + h2, i + 2*h2, ....

_Сcылка на статью habr_ - [метод открытой адресации](https://habr.com/ru/post/247843/). (https://habr.com/ru/post/247843/).

---

## Где поиск выполняется быстрее: в списках или словарях?
В списках во время поиска надо пройтись по всем значениям. Это занимает O(n) времени. Поиска в словаре по ключу занимает O(1), потому что в основе используется хэш-таблица.

Из этого видно, что поиск в словарях работает быстрее. Это особенно заметно при большом количестве значений. Но есть обратная сторона: словари не всегда удобно использовать для хранения большого количества данных из-за требования уникальных ключей.
