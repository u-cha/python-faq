---
title: Итераторы и генераторы
description: Вопросы и ответы по итераторам и генераторам Python на сайте-методичке Python FAQ.
---


## Итераторы
**Итератор** в Python - это объект, который реализует методы __\_\_iter\_\___ и __\_\_next\_\___ . 

Метод __\_\_iter\_\_()__ возвращает сам итератор, а метод __\_\_next\_\___ возвращает следующий элемент последовательности.
Когда элементы заканчиваются, __\_\_next\_\___ должен вызвать исключение `StopIteration`.

    class Squares:
        def __init__(self, max_value):
            self.max_value = max_value
            self.current = 1
    
        def __iter__(self):
            # Метод __iter__ делает объект итератором. 
            # Возвращаем самого себя, так как класс сам является итератором
            return self
    
        def __next__(self):
            # Метод __next__ вызывается при каждой итерации
            if self.current <= self.max_value:
                result = self.current ** 2
                self.current += 1
                return result
            else:
                raise StopIteration

    squares = Squares(5)
    for square in squares:
        # На каждой итерации вызывается метод __next__ и выводится результат
        print(square)

---

## Генераторы
**Генератор** в Python - это функция, которая использует выражение **yeild** для генерации серии значений для итерации. Это особый тип генератора, который автоматически генерирует методы __\_\_iter\_\_()__ и __\_\_next\_\_()__ . Главное отличие заключается в том, что значения генерируются по требованию(ленивые вычисления). Каждый раз, когда функция-генератор возобновляет выполнение, она продолжает выполнение с точки последнего вызова

Основные отличия от итератора:

1. **Создание**: Итераторы создаются путем определения класса с методами             __\_\_iter\_\_()__ и __\_\_next\_\_()__. Генераторы создаются путем написания обычной функции с использованием выражения `yield`.
    
2. **Состояние**: Итераторы сохраняют свое состояние с помощью переменных класса. Генераторы сохраняют свое состояние в контексте локальных переменных, которые восстанавливаются при каждом выходе и входе из функции-генератора.

3. **Оперативная память**: Генераторы обычно используют меньше памяти, поскольку они генерируют элементы один за другим, а не хранят весь итерируемый объект в памяти.
    
4. **Удобство написания**: Функции-генераторы часто легче написать и понять, чем полноценные итераторы, потому что не требуются дополнительные методы и классы.
    
5. **Производительность**: Генераторы могут повышать производительность, так как значения вычисляются только тогда, когда они необходимы.

### Преимущества генератора
Генераторы не хранят весь набор данных в памяти, а вычисляют значения по мере необходимости, используя ключевое слово yield. Это особенно полезно при работе с большими файлами или наборами данных, которые могут не поместиться в оперативную память 

- **Улучшенная производительность**:
Благодаря ленивым вычислениям, генераторы могут значительно ускорить выполнение программы, так как они не тратят время на создание и хранение промежуточных результатов.Это особенно актуально при работе с большими объемами данных.
- **Удобство и читаемость кода**:
Генераторы позволяют упростить код, избегая громоздких циклов и временных переменных. Это делает код более лаконичным и понятным, что облегчает его поддержку и отладку
- **Обработка бесконечных последовательностей**:
Генераторы могут быть использованы для создания итераторов, которые генерируют бесконечные последовательности данных, например, последовательность случайных чисел или значения в цикле.
- **Управление состоянием**:
Генераторы сохраняют свое состояние между вызовами, что позволяет им возобновлять вычисления с того места, где они были остановлены. Это дает больший контроль над процессом генерации данных.
В целом, генераторы в Python - это мощный инструмент для оптимизации кода и работы с большими объемами данных, обеспечивая при этом гибкость и удобство в использовании.

---

## Что такое list/dict comprehension
Генераторы коллекций - короткий(относительно цикла for) способ создавать коллекции на основе других коллекций.

Эти генераторы позволяют нам:

- Кратко и просто создавать коллекции(при несложной логике).
- Экономить время(генераторы более эффективны, чем цикл for).
- Подходит для адептов функционального программирования, так как происходит именно генерация новой коллекции, а не изменение существующей.

**List/dict comprehensions** в Python - это компактный способ создания новых списков (list comprehension) или словарей (dict comprehension) на основе существующих итерабельных объектов. Они позволяют заменить традиционные циклы for более лаконичным синтаксисом, делая код более читаемым и эффективным.

List comprehension имеет следующий синтаксис:

    [expression for item in iterable if condition]
Dict comprehension имеет аналогичный синтаксис для создания словарей:

    {key_expression: value_expression for item in iterable if condition}
