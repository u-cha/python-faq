---
title: ООП Python
description: Вопросы и ответы по ООП Python на сайте-методичке Python FAQ.
---


## Принципы ООП

- Абстракция
- Наследование
- Инкапсуляция
- Полиморфизм

**Наследование**  — способ создания класса. Его суть заключается в том, что функциональность нового класса наследуются от уже существующего класса. Новый класс называется производным (дочерним). Существующий — базовым (родительским).

**Инкапсуляция** -  мы можем ограничить доступ к методам и переменным, что предотвратит модификацию данных — это и есть инкапсуляция. Приватные атрибуты выделяются нижним подчеркиванием: одинарным _ или двойным __.

**Полиморфизм**  — особенность ООП, позволяющая использовать одну функцию для разных форм (типов данных).

**Абстракция** используется, чтобы скрыть внутренние характеристики функции от пользователей.


---

## Магические методы
Магическими методами называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. Магические они потому, что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. Например, функция len() вызывает метод __len__() переданного объекта. Метод __add__(self, other) вызывается автоматически при сложении оператором +.

Перечислим некоторые магические методы:

- __init__: инициализатор класса
- __add__: сложение с другим объектом
- __eq__: проверка на равенство с другим объектом
- __iter__: возвращает итератор

### Какие есть магические методы и для чего они используются?
Магические методы (иногда также называемые специальными методами) начинаются и заканчиваются двумя подчеркиваниями (например, **`__init__()`**). Они позволяют определить различное поведение для объектов, таких как перегрузка операторов, создание контекстных менеджеров, управление атрибутами и т. д. Вот несколько примеров наиболее часто используемых методов и их назначения:

1. **`__init__(self, ...)`:** Вызывается при создании нового экземпляра класса и используется для инициализации его атрибутов.

2. **`__repr__(self)`:** Возвращает "официальное" строковое представление объекта. Это используется для отладки и для получения строкового представления объекта при выводе в интерактивной оболочке.

3. **`__str__(self)`:** Возвращает "неформальное" строковое представление объекта. Обычно используется для представления объекта в удобочитаемой форме для конечного пользователя.

4. **`__len__(self)`:** Возвращает длину объекта. Это используется, когда объект поддерживает операцию получения длины, например, для строк, списков и т. д.

5. **`__getitem__(self, key)`:** Позволяет объекту поддерживать доступ к элементам по индексу, как это делают списки и словари.

6. **`__setitem__(self, key, value)`:** Позволяет объекту устанавливать значение элемента по ключу.

7. **`__delitem__(self, key)`:** Позволяет объекту удалять элемент по ключу.

8. **`__iter__(self)`:** Возвращает итератор для объекта, позволяя его использовать в циклах `for`.

9. **`__next__(self)`:** Вызывается итератором для получения следующего элемента в последовательности.

10. **`__enter__(self)`, `__exit__(self, exc_type, exc_value, traceback)`:** Позволяют объекту быть контекстным менеджером, что позволяет определять действия, которые должны выполняться при входе и выходе из контекста.

Это лишь несколько примеров магических методов, которые можно определить. Они предоставляют мощные средства для определения поведения объектов и делают Python гибким и выразительным.

---

## Отличие init() от new()
Основное различие между этими двумя методами состоит в том, что **__new__** обрабатывает создание объекта, а **__init__** обрабатывает его инициализацию.

**__new__** вызывается автоматически при вызове имени класса (при создании экземпляра), тогда как **__init__** вызывается каждый раз, когда экземпляр класса возвращается **__new__**, передавая возвращаемый экземпляр в **__init__** в качестве параметра `self`, поэтому даже если вы сохранили экземпляр где-нибудь глобально/статически и возвращали его каждый раз из **__new__**, для него все-равно будет каждый раз вызываться **__init__**.
Из вышесказанного вытекает что сначала вызывается **__new__**, а потом **__init__**
---

## Что такое MRO?
**Method resolution order** - порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей.

В классических классах поиск при наследовании по ссылкам на имена осуществляется в следующем порядке:

1. Сначала экземпляр
2. Затем его класс
3. Далее все суперклассы его класса с обходом сначала с глубину, а затем слева направо


---

## Миксины
В Python **миксины (mixins)** - это классы, предназначенные для добавления функциональности в другие классы через множественное наследование, не являясь при этом самостоятельными классами для создания экземпляров. Они предоставляют набор методов, которые можно "подмешать" к другим классам для расширения их возможностей.

**Назначение**:
Миксины служат для повторного использования кода и предотвращения дублирования, добавляя определенную функциональность к нескольким классам без создания сложных иерархий наследования. 

**Особенности**:
Миксины обычно не содержат данных (атрибутов), а только методы, определяющие поведение. Они предназначены для использования в качестве "строительных блоков", которые можно комбинировать для создания более сложных классов. 

**Использование**:
Миксины включаются в другие классы через множественное наследование. Например, если у вас есть класс User и вы хотите добавить функциональность логирования, вы можете создать миксин LoggingMixin с методами логирования и унаследовать от него класс User. 

**Преимущества**:
Повторное использование кода: Миксины позволяют избежать дублирования кода, предоставляя общую функциональность для нескольких классов.

**Гибкость**: 
Они обеспечивают гибкость при проектировании классов, позволяя легко добавлять или изменять функциональность.

Поддержка чистого кода: Миксины способствуют созданию более читаемого и поддерживаемого кода, разделяя функциональность на отдельные компоненты. 

Пример:

       class LoggingMixin:
           def log(self, message):
               print(f"Logging: {message}")
    
    
       class User(LoggingMixin):
           def __init__(self, name):
               self.name = name
               self.log(f"User {self.name} created")


       def say_hello(self):
           self.log(f"Hello, my name is {self.name}")

       user = User("Alice")
       user.say_hello()
В этом примере, LoggingMixin предоставляет метод log, который используется классом User. Класс User при этом несет ответственность только за свою логику, а логирование делегируется LoggingMixin. 
В заключение: Миксины - это полезный инструмент в Python для создания гибкого, повторно используемого и поддерживаемого кода, позволяющий избегать сложных иерархий наследования и дублирования

---

## Что такое slots?
Это магический метод, который позволяет нам иметь только заданный набор атрибутов в экземпляре класса.
Атрибут slots в классе Python используется для оптимизации памяти и ускорения работы с объектами класса. Он позволяет явно указать, какие атрибуты объекта будут использоваться, а какие нет.

Когда вы определяете класс, Python создает для каждого экземпляра этого класса словарь, который содержит все его атрибуты. Это может быть выгодным в том случае, если у вас много различных атрибутов, но может привести к большому расходу памяти, если вы создаете много экземпляров класса с небольшим количеством атрибутов.

Атрибут slots позволяет определить, какие атрибуты должны быть на самом деле созданы для каждого экземпляра класса, и в какой момент их можно будет получить. Если вы используете атрибут slots, Python уже не будет создавать словарь для каждого экземпляра класса, а будет использовать непосредственно массив атрибутов, что может ускорить работу программы и уменьшить использование памяти.

Например, если у вас есть класс Person с атрибутами name и age, вы можете определить slots следующим образом:

    class Person:
        __slots__ = ['name', 'age']
    
        def __init__(self, name, age):
            self.name = name
            self.age = age

Таким образом, каждый экземпляр класса Person будет содержать только атрибуты name и age, и никакие другие атрибуты не будут созданы.

```python
class PointSlots:

    __slots__ = ('x','y') # Перечисляем все возможные атрибуты экземпляров класса
                          
    def __init__(self, x, y):
        self.x = x
        self.y = y
```
### Плюсы:

**Фиксированность** - после указания _`__slots__`_ добавление новых атрибутов в экземпляр класса, кроме уже указанных, невозможно

**Скорость работы программы** - используемая коллекция для хранения имён переменных в **slots** позволяет ускорить работу программы

**Использование памяти** - уменьшение количества занимаемой памяти при использовании _`__slots_`_ связано с тем, что в _`__slots__`_ хранятся только значения из пространства имён

---

## Дескрипторы
Дескрипторы в Python — это объекты, которые реализуют один или несколько специальных методов: __get__(), __set__() и __delete__(). Они позволяют контролировать доступ к атрибутам класса и определять дополнительное поведение при их получении, изменении или удалении.
Используются для кэширования, валидации.

    class PositiveValue:
        def __get__(self, instance, owner):
            return instance.__dict__.get(self, None)
    
        def __set__(self, instance, value):
            if value < 0:
                raise ValueError("Значение должно быть положительным!")
            instance.__dict__[self] = value

    class MyClass:
        number = PositiveValue()
    
    obj = MyClass()
    obj.number = 10      # Корректная установка значения
    print(obj.number)    # Выведет: 10
    
    obj.number = -5      # Вызывает ValueError: Значение должно быть положительным!

Дескрипторы — это объекты Python, которые определяют, как другие объекты должны вести себя при доступе к атрибуту. Дескрипторы могут использоваться для реализации протоколов, таких как протокол доступа к атрибутам, протокол дескрипторов и протокол методов.

Декораторы — это функции Python, которые принимают другую функцию в качестве аргумента и возвращают новую функцию. Декораторы обычно используются для изменения поведения функции без изменения ее исходного кода.

Разница между дескриптором и декоратором заключается в том, что дескрипторы используются для определения поведения атрибутов объекта, в то время как декораторы используются для изменения поведения функций. Однако, декораторы могут использоваться для реализации протоколов дескрипторов.

Например, декоратор @property можно использовать для создания дескриптора доступа к атрибутам. Он преобразует метод класса в дескриптор, который позволяет получать, устанавливать и удалять значение атрибута как обычный атрибут объекта.

---

## Classmethod и staticmethod
**`classmethod`** и **`staticmethod`** - это специальные декораторы, которые позволяют определять методы в классах с особым поведением. Однако они имеют различия в том, как они обрабатывают аргументы и как они взаимодействуют с экземплярами класса.

**classmethod:**

- Декоратор преобразует обычный метод класса в тот, который принимает первым аргументом ссылку на класс (обычно называемый **`cls`**).
- Это означает, что метод **`classmethod`** может обращаться к атрибутам и вызывать другие методы класса через ссылку на сам класс, а не через экземпляр класса.
- Может использоваться, например, для создания альтернативных конструкторов класса или для работы с классовыми переменными.

```python
class MyClass:
    class_attribute = 123
    
    @classmethod
    def class_method(cls):
        return cls.class_attribute

print(MyClass.class_method())  # Выведет: 123
```

**staticmethod:**

- Декоратор создает метод класса, который не принимает ссылку на сам класс (неявно или явно), и не принимает ссылку на экземпляр класса (обычно называемый **`self`**).
- Это означает, что **`staticmethod`** является статическим методом и может быть вызван как из класса, так и из экземпляра класса, но не имеет доступа к атрибутам и методам класса или экземпляра.
- Статические методы могут быть полезны для группировки связанных функций внутри класса или для создания методов, которые не требуют доступа к состоянию класса или экземпляра.

```python
class MyClass:
    @staticmethod
    def static_method():
        return "This is a static method"

print(MyClass.static_method())  # Выведет: This is a static method
```

Основное отличие между **`classmethod`** и **`staticmethod`** заключается в том, что **`classmethod`** принимает ссылку на класс, а **`staticmethod`** - нет.

---

## Метаклассы
**Метаклассы** — это классы, которые определяют поведение других классов. Они используются для изменения способа, которым Python создает и обрабатывает классы.

Метаклассы могут быть полезны в следующих случаях:

- при необходимости динамического изменения поведения класса, например, если вы хотите добавить или удалить атрибут или метод класса во время выполнения программы;
- при создании классов из данных, которые не заранее известны. Например, вы можете создавать классы на основе определенных условий во время выполнения программы;
- для создания фреймворков и библиотек, которые нужно настраивать под конкретные требования и при этом сохранить простоту интерфейса.
- Они также могут использоваться для создания классов с определенными свойствами, например, классов, которые автоматически регистрируются в библиотеке или классов, которые автоматически сериализуются и десериализуются для совместимости с другими системами.

Пример использования метакласса для добавления атрибута к классу:

    class MyMeta(type):
        def __new__(cls, name, bases, dct):
            dct['my_attribute'] = 42
            return super(MyMeta, cls).__new__(cls, name, bases, dct)
    
    class MyClass(metaclass=MyMeta):
        pass
    
    print(MyClass.my_attribute)

В этом примере создается метакласс MyMeta, который добавляет атрибут my_attribute к любому классу, который использует данный метакласс для своего создания. Затем создается класс MyClass, который использует метакласс MyMeta. При вызове print(MyClass.my_attribute) выводится значение 42, так как этот атрибут был добавлен в момент создания класса.
Метаклассы - это концепция, которая позволяет контролировать создание классов. Классы являются объектами, и они создаются с помощью других классов, которые называются метаклассами. Вот некоторые ключевые моменты о них:

1. **Классы как объекты:** Классы являются объектами первого класса, что означает, что они могут быть созданы, изменены и переданы как аргументы функций.

2. **Типы и метаклассы:** Каждый объект имеет тип, который определяется его классом. Этот класс, определяющий тип объекта, называется метаклассом. По умолчанию для всех классов метаклассом является _`type`_.

3. **Использование метаклассов:** Метаклассы можно использовать для изменения поведения создания классов. Это может быть полезно для автоматического добавления методов, проверки атрибутов или изменения наследования классов.

4. **Ключевые методы метакласса:** Для создания собственного метакласса обычно определяются методы _`__new__()`_ и _`__init__()`_. Метод _`__new__()`_ вызывается перед созданием экземпляра класса, а метод _`__init__()`_ вызывается после создания экземпляра.

Пример создания метакласса:

    class MyMeta(type):
        def __new__(cls, name, bases, dct):
            # Изменяем или расширяем класс
            dct['custom_attribute'] = 'This is a custom attribute'
            return super().__new__(cls, name, bases, dct)
    
    class MyClass(metaclass=MyMeta):
        pass
    
    obj = MyClass()
    print(obj.custom_attribute)  # Вывод: This is a custom attribute

В этом примере _`MyMeta`_ - это метакласс, который изменяет класс _`MyClass`_, добавляя к нему новый атрибут _`custom_attribute`_.

Мы создаём класс для того, чтобы создавать объекты, так? А классы являются объектами. Метакласс это то, что создаёт эти самые объекты. Они являются классами классов, можно представить это себе следующим образом:

    MyClass = MetaClass()
    MyObject = MyClass()

Мы уже видели, что type позволяет делать что-то в таком духе:

    MyClass = type('MyClass', (), {})

Это потому что функция type на самом деле является метаклассом. type это метакласс, который Питон внутренне использует для создания всех классов.


